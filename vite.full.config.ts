import { build } from 'vite'
import path from 'node:path'
import { readdir, readFile, stat, writeFile } from 'node:fs/promises'
import { fileURLToPath } from 'node:url'
import { viteStaticCopy } from 'vite-plugin-static-copy'
import dts from 'vite-plugin-dts'
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import * as url from 'node:url'

import { colorPalette } from './src/shared/tools/tailwind-config.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export async function readDeps(dir, prefix: string[] = []) {
  let output =
    prefix.length === 0
      ? [
          {
            entry: './src/components/index.ts',
            source: './components/index',
            name: 'components',
            requires: './dist/components/index.cjs',
            imports: './dist/components/index.js',
            types: './dist/components/index.d.ts',
            fileName: 'components/index',
          },
        ]
      : []
  const list = await readdir(dir)
  for (const file of list) {
    if (file === '.' || file === '..') {
      continue
    }
    const info = await stat(path.join(dir, file))
    if (info.isDirectory()) {
      if (file !== 'shared') {
        const subOutput = await readDeps(path.join(dir, file), [
          ...prefix,
          file,
        ])
        output = output.concat(subOutput)
        output.sort(({ name: a }, { name: b }) => {
          if (a > b) {
            return 1
          }

          if (a < b) {
            return -1
          }
          return 0
        })
      }
    } else if (/components\//.test(dir) && /\.ts$/.test(file)) {
      if (file !== 'index.ts') {
        continue
      }
      const entry = `./${path.join(dir, file)}`
      const item = {
        entry,
        source: `./${path
          .relative(path.join(__dirname, 'src'), entry)
          .replace(/.ts$/, '')}`,
        name: path.basename(path.dirname(entry)),
        requires: `./${path
          .join('dist', path.relative(path.join(__dirname, 'src'), entry))
          .replace(/.ts$/, '.cjs')}`,
        imports: `./${path
          .join('dist', path.relative(path.join(__dirname, 'src'), entry))
          .replace(/.ts$/, '.js')}`,
        types: `./${path
          .join('dist', path.relative(path.join(__dirname, 'src'), entry))
          .replace(/.ts$/, '.d.ts')}`,
        fileName: `${path.relative(
          path.join(__dirname, 'src'),
          entry.replace(/\.ts$/, '')
        )}`,
      }
      output.push(item)
      output.sort(({ name: a }, { name: b }) => {
        if (a > b) {
          return 1
        }

        if (a < b) {
          return -1
        }
        return 0
      })
    }
  }
  return output
}

async function writeIndex() {
  const list = await readDeps('src')
  const filePath = path.join(__dirname, 'src/components/index.ts')
  const oldFile = await readFile(filePath, 'utf-8')
  // Filter out tailwind-element from component exports to avoid circular dependency
  // TailwindElement should be imported directly from '@lukso/web-components/dist/shared/tailwind-element'
  const componentExports = list
    .slice(1)
    .filter(({ name }) => name !== 'tailwind-element')
    .map(({ source }) => {
      const file = `./${path.relative(
        './components',
        source.replace(/\/index\.ts$/, '')
      )}`
      return `export * from '${file}'`
    })
    .join('\n')
  const newFile = `// DO NOT MODIFY MANUALLY. This file is auto generated by Vite build process.\n${componentExports}\n`
  if (oldFile !== newFile) {
    console.log(`writing ${filePath}`)
    await writeFile(filePath, newFile)
  }
}

/**
 * Write the color palette as CSS variables to a Sass file
 */
async function writeSass() {
  const filePath = path.join(__dirname, 'src/shared/styles/colors.scss')
  const oldFile = await readFile(filePath, 'utf-8')

  const output = [
    '// DO NOT MODIFY MANUALLY. This file is auto generated by Vite build process.',
    ':root {',
  ]

  for (const [group, colorValues] of Object.entries(colorPalette)) {
    for (const [color, value] of Object.entries(colorValues)) {
      output.push(`  --${group}-${color}: ${value};`)
    }
  }
  output.push('}', '')

  const newFile = output.join('\n')

  if (oldFile !== newFile) {
    console.log(`writing ${filePath}`)
    await writeFile(filePath, newFile)
  }
}

async function writePackage() {
  const list = await readDeps('src')
  const exp = {
    '.': {
      require: './dist/index.cjs',
      import: './dist/index.js',
      types: './dist/index.d.ts',
    },
    './tailwind.config': './tailwind.config.cjs',
    './postcss.config': './postcss.config.cjs',
    './tools/assets/fonts/': './tools/assets/fonts/',
    './tools/assets/fonts': {
      require: './tools/assets/fonts/index.cjs',
      import: './tools/assets/fonts/index.js',
      types: './tools/assets/fonts/index.d.ts',
    },
    './tools/assets/images/': './tools/assets/images/',
    './tools/assets/images': {
      require: './tools/assets/images/index.cjs',
      import: './tools/assets/images/index.js',
      types: './tools/assets/images/index.d.ts',
    },
    './tools/assets/': './tools/assets/',
    './tools/assets': {
      require: './tools/assets/index.cjs',
      import: './tools/assets/index.js',
      types: './tools/assets/index.d.ts',
    },
    './tools/styles/': './tools/styles/',
    './tools/styles': {
      require: './tools/styles/index.cjs',
      import: './tools/styles/index.js',
      types: './tools/styles/index.d.ts',
    },
    './tools/sass/': './tools/sass/',
    './tools/sass': {
      require: './tools/sass/index.cjs',
      import: './tools/sass/index.js',
      types: './tools/sass/index.d.ts',
    },
    './tools/tailwind-config': {
      require: './tools/tailwind-config.cjs',
      import: './tools/tailwind-config.js',
      types: './tools/tailwind-config.d.ts',
    },
    './tools/copy-assets': {
      require: './tools/copy-assets.cjs',
      import: './tools/copy-assets.js',
      types: './tools/copy-assets.d.ts',
    },
    './tools/': './tools/',
    './tools': {
      require: './tools/index.cjs',
      import: './tools/index.js',
      types: './tools/index.d.ts',
    },
    './custom-elements': './custom-elements.json',
    './custom-elements.json': './custom-elements.json',
    './package.json': './package.json',
  }
  for (const { fileName, requires, imports, types } of list) {
    exp[`./dist/${fileName.replace(/\/index$/, '')}`] = {
      require: requires,
      import: imports,
      types,
    }
  }

  // Read the root package.json
  const fullContent = await readFile('./package.json', 'utf-8')
  const fullPack = JSON.parse(fullContent)

  // Generate package.json from scratch
  const pack = {
    name: '@lukso/web-components',
    version: fullPack.version,
    type: 'module',
    files: [
      'dist',
      'tools',
      'templates',
      'tailwind.config.cjs',
      'postcss.config.cjs',
      'README.md',
      'LICENSE',
    ],
    main: './dist/index.cjs',
    module: './dist/index.js',
    types: './dist/index.d.ts',
    sideEffects: [
      './dist/index.js',
      './dist/index.cjs',
      './dist/components/**/index.js',
      './dist/components/**/index.cjs',
    ],
    exports: exp,
    dependencies: fullPack.dependencies || {},
    repository: fullPack.repository,
    customElements: 'custom-elements.json',
  }

  const newContent = `${JSON.stringify(pack, null, '\t')}\n`
  console.log('writing ./package/package.json')
  await writeFile('./package/package.json', newContent)

  return exp
}

const chokidar = {
  ignored: ['node_modules/**', 'tools/**', 'dist/**'],
}

const resolve = {
  alias: {
    '@': path.resolve(__dirname, './src'),
  },
}

export async function run(argv) {
  const { mode } = argv
  await writeIndex()
  await writePackage()
  await writeSass()
  const list = await readDeps('src')
  const libs = [
    {
      fileName: 'index',
      name: 'web_components',
      entry: './src/index.ts',
    },
    {
      fileName: 'tailwind-config',
      name: 'web_component_tailwind_config',
      entry: './src/shared/tools/tailwind-config.ts',
    },
  ].concat(
    list.map(({ entry, fileName, name }) => {
      console.log(`setting up ${entry}`)
      return {
        fileName,
        name: `web_components_${name.replace(/-/g, '_')}`,
        entry,
      }
    })
  )

  try {
    const entries = {}
    for (const { fileName, entry } of libs) {
      entries[fileName] = entry
    }
    await build({
      configFile: false,
      resolve,
      build: {
        minify: false,
        lib: {
          entry: entries,
          formats: ['es', 'cjs'],
        },
        target: 'esnext',
        emptyOutDir: true,
        outDir: './package/dist',
        watch:
          mode !== 'production'
            ? {
                clearScreen: false,
                chokidar,
                exclude: ['node_modules/**', 'tools/**', 'dist/**'],
              }
            : null,
        rollupOptions: {
          external: [
            'fs',
            'path',
            'node:fs',
            'node:path',
            // External library dependencies - consumers will provide these
            'lit',
            'lit/decorators.js',
            'lit/directives/class-map.js',
            'lit/directives/if-defined.js',
            'lit/directives/style-map.js',
            'lit/directives/unsafe-html.js',
            'lit/static-html.js',
            '@lit-labs/motion',
            /^@lukso\/core/,
            /^tippy\.js/,
            /^qr-code-styling/,
            /^ethereum-blockies-base64/,
            /^marked/,
            /^clsx/,
            /^tailwind-merge/,
            /^tailwind-variants/,
            /^viem/,
            /^web3-utils/,
            /^axe-core/,
          ],
          output: {
            chunkFileNames: 'chunks/[name]-[hash].js',
          },
        },
      },
      plugins: [
        viteStaticCopy({
          targets: [
            {
              src: ['./LICENSE', './README.md'],
              dest: '..',
            },
            {
              src: 'src/components/lukso-icon/vuesax',
              dest: 'components/lukso-icon',
            },
            {
              src: './templates',
              dest: '..',
            },
          ],
        }),
        dts({
          exclude: [
            './src/shared/tools',
            './src/shared/assets',
            './src/shared/styles',
            './src/shared/directives',
          ],
          outDir: './package/dist',
          beforeWriteFile: (filePath, content) => {
            return { filePath: filePath.replace('/src/', '/'), content }
          },
        }),
        dts({
          include: ['./src/shared/tools/tailwind-config.ts'],
          beforeWriteFile: (filePath, content) => {
            return {
              filePath: filePath.replace('/shared/tools/', '/'),
              content,
            }
          },
          outDir: './package/dist',
        }),
      ].filter(item => item),
    })
  } catch (err) {
    console.error(err)
  }
}

if (import.meta.url.startsWith('file:')) {
  // (A)
  const modulePath = url.fileURLToPath(import.meta.url)
  if (process.argv[1] === modulePath) {
    // (B)
    const argv = await yargs(hideBin(process.argv)).argv
    run(argv)
      .then(() => {
        if (argv.mode === 'production') {
          console.log('build finished')
          process.exit(0)
        }
      })
      .catch(err => {
        console.error(err)
        process.exit(1)
      })
  }
}
